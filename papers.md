# Pi2 Papers

## Semantics-Based Execution and the LLVM Backend of the K Framework Version 1.0

**Authors:** Pi Squared Inc.

**Date:** February 2025

**Source:** https://raw.githubusercontent.com/Pi-Squared-Inc/pi2-gpt/refs/heads/papers/papers/Semantics_based_execution_and_the_LLVM_backend/full.md

### Abstract

The K framework is a semantics-based approach to language design and implementation. From a single defnition of a language’s syntax and operational semantics, a full set of tools can be extracted automatically, including a concrete interpreter for programs in that language. In this paper, we identify the most critical performance bottleneck for such interpreters: compiling fast decision trees for a subset of associativecommutative pattern-matching problems. We demonstrate a decision tree-based compilation algorithm that substantially extends existing methods with support for fast runtime collection data structures. We show that LLVM-based interpreters generated by $\mathbb{K}$ perform comparably to ones written by hand for interpreted languages such as EVM and are practical for real-world adoption. Moreover, we show that optimizations that are only possible in the presence of a formal language semantics make Compositional Symbolic Execution (CSE), in fact, outperform manuallywritten language implementations. Automatically generating efcient and correct-by-construction language implementations from formal semantics is the holy grail of the programming language feld; after more than two decades of sustained innovation and engineering, $\mathbb{K}$ is proudly almost there.

## The Pi Squared (π²) White Paper Version 1.0

**Authors:** Pi Squared Inc.

**Date:** February 2025

**Source:** https://raw.githubusercontent.com/Pi-Squared-Inc/pi2-gpt/refs/heads/papers/papers/The_Pi_Squared___2__WhitepaperVersion_1_0/full.md

### Abstract

Pi Squared is set to massively disrupt the state-of-the-art and revolutionize Web3 by making the following features mainstream:

1. Universality: Programs will be written in any programming languages, virtual machines (VMs), or instruction sets that applications choose. Developers will no longer need to learn poorly designed languages only because that’s the only way to write Web3 programs. Program executions will be proved using any mathematical or cryptographic proof systems that the applications choose. They will no longer need to take the risk of introducing bugs and increasing complexity by translating their code to restricted or obscure low-level languages, only because that is the only way to use existing zeroknowledge virtual machines (zkVMs) to prove their executions. And fnally, applications will choose which consensus fts them best: can be a total-order consensus, like in blockchains, rollups, appchains, etc., or a partial-order or even no order at all, like in voting, auction, or trading applications. Applications will no longer need to squeeze their transactions in a global total order across all the applications in the universe, through a narrow pipe.

2. Correctness: All the above will be correct by construction. Specifically, once a formal semantics of the language is provided $^{1}$ , all the execution and proving tools for that language are automatically derived and everything they do is provably and verifably correct at no additional efort. No formal verifcation of translators, compilers, interpreters, VMs, zkVMs, etc., will be required.

3. Performance: No, universality and correctness should not and will not come at the cost of performance. Quite the contrary. After more than ffty (50) years of sustained research and engineering, the formal semantics domain has reached a level of maturity and tooling that allows semantics-based execution to match and even outperform the traditional, ad-hoc manual implementations of compilers and interpreters/VMs. The future is even brighter because formal semantics enables a series of optimizations that are simply not possible using traditional approaches, such as symbolic semantic summarization of basic blocks or using formal verifcation to non-asymptotically compress or even eliminate computation.

This paper gives a high-level overview of Pi Squared and of its three major technical components, namely the K Framework, Proof of Proof, and the Universality Stack, focusing on what and why. For how, the reader is encouraged to dive deeper into our three component-specifc white papers as well as our research and peer-reviewed publications at pi2.network.

## Proof of Proof:A Universal Verifiable Computing Framework Version 1.0

**Authors:** Pi Squared Inc.

**Date:** February 2025

**Source:** https://raw.githubusercontent.com/Pi-Squared-Inc/pi2-gpt/refs/heads/papers/papers/Proof_of_Proof/full.md

### Abstract

This paper gives an overview of the Proof of Proof approach to universal and correct-by-construction verifable computing proposed by the Pi Squared team. The idea of Proof of Proof is to separate the three underlying concerns: computation, verifcation, and cryptography.

First, recent developments in executable formal semantics allow us to efciently and completely automatically reduce computation to mathematical proof. The universality of Proof of Proof comes from the fact that there is only one language for mathematical proofs, which works with math proofs corresponding to any computations done with any programs in any programming languages (PLs) or virtual machines (VMs).

Second, the generated math proofs are verifed, not trusted, with a disarmingly simple and small proof checker of only a few hundred lines of code. The correctness of Proof of Proof comes from the fact that no (usually complex and error-prone) compilers, interpreters, or even formal provers or language frameworks need to be trusted or formally verifed: all these become only instruments to assist the generation of math proofs; the math proofs, and not the tools that produced them, are the ultimate correctness arguments for the computations from which they were derived.

Finally, recent developments in cryptography, e.g., SNARKS, STARKS and zero-knowledge (ZK), allow us to implement the math proof checker as a cryptographic circuit, which efectively allows us to produce ZK proofs for the integrity of the math proofs, that is, (ZK) Proofs of (math) Proofs.

This paper does not discuss semantics-based execution in-depth, nor recent developments in the context of the K framework that make semantics-based execution comparable in performance with manual, adhoc language implementations. If the reader is interested in how a formal reasoning engine like K can execute programs as fast as or faster than dedicated interpreters, e.g., EVM programs as fast as or faster than Geth, they should refer to our white paper dedicated to that topic: “Semantics-based execution and the LLVM backend of the K Framework”. This paper only focuses on how to extract the math proofs from K, verify them, and generate ZK proofs from them.

## Pi Squared's Universality Stack Version 1.0

**Authors:** Pi Squared Inc.

**Date:** February 2025

**Source:** https://raw.githubusercontent.com/Pi-Squared-Inc/pi2-gpt/refs/heads/papers/papers/Universality_Module_Stack/full.md

### Abstract

Blockchain systems have faced persistent challenges related to fragmentation, inefciency, and limited interoperability. The monolithic architecture of existing blockchains tightly couples execution, settlement, consensus, and data, leading to scalability bottlenecks and isolated ecosystems. Developers are restricted by language-specifc environments, while cross-chain interactions rely on insecure and inefcient bridging mechanisms. These limitations stife innovation, increase costs, and create security vulnerabilities, preventing the seamless development and deployment of decentralized applications across multiple blockchain networks.

To address these issues, Pi Squared introduces the Universality Stack, a three-tiered architecture comprising the Universal Settlement Layer (USL), the Universal Language Machine (ULM), and the Universal Consensus Protocol (UCP). The USL provides a unifed settlement layer based on verifable claims, eliminating the need for traditional cross-chain bridges The ULM enables smart contract development in any programming language, breaking the constraints of ecosystem-specifc virtual machines. The UCP redefnes consensus by allowing agreement on unordered, independent values, unlocking massive parallelism and improving scalability.

By integrating the USL, the ULM, and the UCP, Pi Squared’s Universality Stack creates a fexible, efcient, and secure foundation for nextgeneration blockchain applications. This framework enhances interoperability, empowers developers with efcient execution of smart contracts in any languages or VMs, and introduces a scalable consensus model that moves beyond traditional ordering constraints. As a result, it enables a more inclusive and adaptable Web3 ecosystem, fostering innovation and broadening access to decentralized applications across diverse platforms.
